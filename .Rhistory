# First translate igraph object to a networkd3 object
g_class_d3 <- igraph_to_networkD3(g_class)
# then we canmake a simple plot
simpleNetwork(g_class_d3$links)
# force network gives us more options.
forceNetwork(Links = g_class_d3$links, Nodes = g_class_d3$nodes, Source = "source",
Target = "target", NodeID = "name", Group = "name", bounded = TRUE,
opacityNoHover = TRUE, opacity = .6)
# We can use graphjs function from threejs to make a bit more fun, interactive 3d plot.
# only way I could get the vertex labels to populate was to use the d3 object.
graphjs(g_class, vertex.label = g_class_d3$nodes$name, main='Network Science Class, Spring 2020',
vertex.color = 'blue', vertex.shape = 'sphere')
# This function will install any packages you dont have installed already.
loadPkg = function(x) { if
(!require(x,character.only=T, quietly =T))
{ install.packages(x,dep=T,repos="http://cran.us.r-project.org");
if(!require(x,character.only=T)) stop("Package not found") } }
loadPkg("networkD3")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
# First lets create an iGraph from literal by defining the edges.
g_class <- (graph_from_literal(
Adwoa+-+Rashmi,
Rashmi+-+Chirag,
Chirag+-+Adwoa,
Adwoa+-+Alex,
Alex+-+Armand,
Alex+-+Bin,
Alex+-+Patrick,
Alex+-+Caroline,
Bin+-+Caroline,
Bin+-+Patrick,
Patrick+-+Fahim,
Patrick+-+Ashigh,
Patrick+-+Caroline,
Patrick+-+Fahim,
Caroline+--Wenyu,
Wenyu+-+Winnie,
Winnie--+Patrick
)
)
# We can use iGraph to plot, but its ultimately unsatisfying.
plot(g_class)
# We can control many of the features, but still not a great visualization.
plot(g_class, edge.arrow.size=.5, vertex.color="gold", vertex.size=20,
vertex.frame.color="gray", vertex.label.color="black",
vertex.label.cex=1, vertex.label.dist=2, edge.curved=0.6)
# Using NetworkD3 to make an interactive visual
# First translate igraph object to a networkd3 object
g_class_d3 <- igraph_to_networkD3(g_class)
# then we canmake a simple plot
simpleNetwork(g_class_d3$links)
# force network gives us more options.
forceNetwork(Links = g_class_d3$links, Nodes = g_class_d3$nodes, Source = "source",
Target = "target", NodeID = "name", Group = "name", bounded = TRUE,
opacityNoHover = TRUE, opacity = .6)
# We can use graphjs function from threejs to make a bit more fun, interactive 3d plot.
# only way I could get the vertex labels to populate was to use the d3 object.
graphjs(g_class, vertex.label = g_class_d3$nodes$name, main='Network Science Class, Spring 2020',
vertex.color = 'blue', vertex.shape = 'sphere')
setwd("~/Documents/projects/network_science_flights")
oadPkg('dplyr')
library(dplyr)
loadPkg('readr')
library(readr)
loadPkg("igraph")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
loadPkg('maps')
library(maps)
loadPkg('geosphere')
library(geosphere)
df <- read_csv('data/ontime_rpt_201901.csv')
str(df)
summary(df)
head(df)
## Lets try to build a network from edges
edges <- select(df, DEST, ORIGIN)
head(edges)
flight_graph <- graph_from_data_frame(edges, directed=T)
degree(flight_graph)
one_day <- edges[:100]
one_day <- edges[1:100,]
plot(sample_edges)
sample_edges <- edges[1:100,]
plot(sample_edges)
View(sample_edges)
plot(sample_edges)
sample_edges <- graph_from_data_frame(edges[1:100,], directed=T)
plot(sample_edges)
sample_edges <- graph_from_data_frame(edges[1:1000,], directed=T)
plot(sample_edges)
sample_edges <- graph_from_data_frame(edges[1:10000,], directed=T)
plot(sample_edges)
flight_graph <- graph_from_data_frame(edges, directed=T)
degree(flight_graph)
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
str(df)
summary(df)
head(df)
sample_edges <- graph_from_data_frame(edges[1:10000,], directed=T)
plot(sample_edges)
plot(degree(flight_graph))
degree(flight_graph)
max(degree(flight_graph))
hist(degree(flight_graph))
plot(flight_graph)
V(flight_graph)
length(V(flight_graph))
plot(sample_edges)
# This function will install any packages you dont have installed already.
loadPkg = function(x) { if
(!require(x,character.only=T, quietly =T))
{ install.packages(x,dep=T,repos="http://cran.us.r-project.org");
if(!require(x,character.only=T)) stop("Package not found") } }
loadPkg('dplyr')
library(dplyr)
loadPkg('readr')
library(readr)
loadPkg("igraph")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
loadPkg('maps')
library(maps)
loadPkg('geosphere')
library(geosphere)
loadPkg('ggmap')
library(ggmap)
df <- read_csv('data/Air_Data_2018.csv')
df$index <- rownames(df)
## Using ggmap's geocoding service, which I can enable with my Google API
# Hiding my key since this repo is public.  Writing to my renv.
#register_google(key = , write = TRUE)
# Now get all the nodes as a set, make a new df, and add lon and lat columns
origins <- (select(df, ORIGIN, index))
colnames(origins) <- c('iata_code','index')
dests <- (select(df, DEST, index))
colnames(dests) <- c('iata_code','index')
nodes = unique(c(origins$iata_code, dests$iata_code))
node_df <- as.data.frame(nodes)
node_df$nodes <- as.character(node_df$nodes)
node_df$lon <- NA
node_df$lat <- NA
# This block of code will actually pass the nodes to Google's API for reverse geolocation
# Dont run it too often, only so many API calls
#for(i in 1:nrow(node_df))
#{
#  print(node_df$nodes[i])
# need to add '+Airport' to resolve ambiguities
#  result <- geocode(paste((node_df$nodes[i]),'+Airport'))
#  node_df$lon[i] <- as.numeric(result$lon)
#  node_df$lat[i] <- as.numeric(result$lat)
#}
#node_df$iata_code <- node_df$nodes
#node_df <- select(node_df, c(iata_code, lat, lon))
#write_csv(node_df, 'data/node_locations.csv')
node_df <- read_csv('data/node_locations.csv')
## Merge locs to the edges
origins_loc <- merge(origins, node_df, by = 'iata_code', full.x = T)
colnames(origins_loc) <- c('origin_iata', 'index', 'origin_lat', 'origin_lon')
dests_loc <- merge(dests, node_df, by = 'iata_code', full.x = T)
colnames(dests_loc) <- c('dest_iata', 'index', 'dest_lat', 'dest_lon')
edge_locs <- merge(origins_loc, dests_loc, by = 'index')
edge_locs_no_na <- na.omit(edge_locs)
edge_locs_clean <- edge_locs_no_na %>%
group_by(origin_iata, origin_lon, origin_lat,
dest_iata, dest_lon, dest_lat) %>%
summarise(total = n())
origin_counts <- edge_locs_no_na %>%
group_by(origin_iata) %>%
summarise(total = n())
# Plot on a map.  Once I get the geo coords in, we can start messing around with visuals.
# I'd like to do a time lapse to show the flights over days/months with different colors
# for different attributes, such as airline or how early/late each flight is.
df_map <- edge_locs_clean[order(-edge_locs_clean$total),][1:1000,]
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=10, col="red")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=10, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(10*df_map$total / max(df_map$total))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=10, col="red")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=10, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(10*df_map$total / max(df_map$total))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
}
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(10*df_map$total / max(df_map$total))
lines(arc)
}
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc)
}
source('~/Documents/projects/network_science_flights/plotting_maps.R')
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc)
}
# This function will install any packages you dont have installed already.
loadPkg = function(x) { if
(!require(x,character.only=T, quietly =T))
{ install.packages(x,dep=T,repos="http://cran.us.r-project.org");
if(!require(x,character.only=T)) stop("Package not found") } }
loadPkg('dplyr')
library(dplyr)
loadPkg('readr')
library(readr)
loadPkg("igraph")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
loadPkg('maps')
library(maps)
loadPkg('geosphere')
library(geosphere)
loadPkg('ggmap')
library(ggmap)
df <- read_csv('data/Air_Data_2018.csv')
df$index <- rownames(df)
## Using ggmap's geocoding service, which I can enable with my Google API
# Hiding my key since this repo is public.  Writing to my renv.
#register_google(key = , write = TRUE)
# Now get all the nodes as a set, make a new df, and add lon and lat columns
origins <- (select(df, ORIGIN, index))
colnames(origins) <- c('iata_code','index')
dests <- (select(df, DEST, index))
colnames(dests) <- c('iata_code','index')
nodes = unique(c(origins$iata_code, dests$iata_code))
node_df <- as.data.frame(nodes)
node_df$nodes <- as.character(node_df$nodes)
node_df$lon <- NA
node_df$lat <- NA
# This block of code will actually pass the nodes to Google's API for reverse geolocation
# Dont run it too often, only so many API calls
#for(i in 1:nrow(node_df))
#{
#  print(node_df$nodes[i])
# need to add '+Airport' to resolve ambiguities
#  result <- geocode(paste((node_df$nodes[i]),'+Airport'))
#  node_df$lon[i] <- as.numeric(result$lon)
#  node_df$lat[i] <- as.numeric(result$lat)
#}
#node_df$iata_code <- node_df$nodes
#node_df <- select(node_df, c(iata_code, lat, lon))
#write_csv(node_df, 'data/node_locations.csv')
node_df <- read_csv('data/node_locations.csv')
## Merge locs to the edges
origins_loc <- merge(origins, node_df, by = 'iata_code', full.x = T)
colnames(origins_loc) <- c('origin_iata', 'index', 'origin_lat', 'origin_lon')
dests_loc <- merge(dests, node_df, by = 'iata_code', full.x = T)
colnames(dests_loc) <- c('dest_iata', 'index', 'dest_lat', 'dest_lon')
edge_locs <- merge(origins_loc, dests_loc, by = 'index')
edge_locs_no_na <- na.omit(edge_locs)
edge_locs_clean <- edge_locs_no_na %>%
group_by(origin_iata, origin_lon, origin_lat,
dest_iata, dest_lon, dest_lat) %>%
summarise(total = n())
origin_counts <- edge_locs_no_na %>%
group_by(origin_iata) %>%
summarise(total = n())
# Plot on a map.  Once I get the geo coords in, we can start messing around with visuals.
# I'd like to do a time lapse to show the flights over days/months with different colors
# for different attributes, such as airline or how early/late each flight is.
df_map <- edge_locs_clean[order(-edge_locs_clean$total),][1:10,]
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=10, col="red")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=10, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc)
}
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc)
}
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(1000*df_map$total / max(df_map$total))
lines(arc)
}
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(1000*df_map$total / max(df_map$total))
lines(arc)
}
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=19, col="green")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=19, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=19, col="green")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=19, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=19, col="green")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=19, col="red")
col.1 <- adjustcolor("orange red", alpha=0.2)
col.2 <- adjustcolor("orange", alpha=0.2)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
for(i in 1:nrow(df_map))  {
arc <- gcIntermediate( c(df_map$origin_lon[i], df_map$origin_lat[i]),
c(df_map$dest_lon[i], df_map$dest_lat[i]),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*df_map$total / max(df_map$total))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
points(x=df_map$origin_lon, y=df_map$origin_lat, pch=19, col="green")
points(x=df_map$dest_lon, y=df_map$dest_lat, pch=19, col="red")
loadPkg = function(x) { if
(!require(x,character.only=T, quietly =T))
{ install.packages(x,dep=T,repos="http://cran.us.r-project.org");
if(!require(x,character.only=T)) stop("Package not found") } }
loadPkg('dplyr')
library(dplyr)
loadPkg('readr')
library(readr)
loadPkg("igraph")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
loadPkg('maps')
library(maps)
loadPkg('geosphere')
library(geosphere)
loadPkg('ggmap')
library(ggmap)
df <- read_csv('data/Air_Data_2018.csv')
df$index <- rownames(df)
## Using ggmap's geocoding service, which I can enable with my Google API
# Hiding my key since this repo is public.  Writing to my renv.
#register_google(key = , write = TRUE)
# Now get all the nodes as a set, make a new df, and add lon and lat columns
origins <- (select(df, ORIGIN, index))
colnames(origins) <- c('iata_code','index')
dests <- (select(df, DEST, index))
colnames(dests) <- c('iata_code','index')
nodes = unique(c(origins$iata_code, dests$iata_code))
node_df <- as.data.frame(nodes)
node_df$nodes <- as.character(node_df$nodes)
node_df$lon <- NA
node_df$lat <- NA
# This block of code will actually pass the nodes to Google's API for reverse geolocation
# Dont run it too often, only so many API calls
#for(i in 1:nrow(node_df))
#{
#  print(node_df$nodes[i])
# need to add '+Airport' to resolve ambiguities
#  result <- geocode(paste((node_df$nodes[i]),'+Airport'))
#  node_df$lon[i] <- as.numeric(result$lon)
#  node_df$lat[i] <- as.numeric(result$lat)
#}
#node_df$iata_code <- node_df$nodes
#node_df <- select(node_df, c(iata_code, lat, lon))
#write_csv(node_df, 'data/node_locations.csv')
node_df <- read_csv('data/node_locations.csv')
## Merge locs to the edges
origins_loc <- merge(origins, node_df, by = 'iata_code', full.x = T)
colnames(origins_loc) <- c('origin_iata', 'index', 'origin_lat', 'origin_lon')
dests_loc <- merge(dests, node_df, by = 'iata_code', full.x = T)
colnames(dests_loc) <- c('dest_iata', 'index', 'dest_lat', 'dest_lon')
edge_locs <- merge(origins_loc, dests_loc, by = 'index')
edge_locs_no_na <- na.omit(edge_locs)
edge_locs_clean <- edge_locs_no_na %>%
group_by(origin_iata, origin_lon, origin_lat,
dest_iata, dest_lon, dest_lat) %>%
summarise(total = n())
origin_counts <- edge_locs_no_na %>%
group_by(origin_iata) %>%
summarise(total = n())
# Plot on a map.  Once I get the geo coords in, we can start messing around with visuals.
# I'd like to do a time lapse to show the flights over days/months with different colors
# for different attributes, such as airline or how early/late each flight is.
df_map <- edge_locs_clean[order(-edge_locs_clean$total),][1:10,]
loadPkg = function(x) { if
(!require(x,character.only=T, quietly =T))
{ install.packages(x,dep=T,repos="http://cran.us.r-project.org");
if(!require(x,character.only=T)) stop("Package not found") } }
loadPkg('dplyr')
library(dplyr)
loadPkg('readr')
library(readr)
loadPkg("igraph")
library(igraph) # Load the igraph package
loadPkg("networkD3")
library(networkD3)
loadPkg("threejs")
library(threejs)
loadPkg('maps')
library(maps)
loadPkg('geosphere')
library(geosphere)
loadPkg('ggmap')
library(ggmap)
df <- read_csv('data/Air_Data_2018.csv')
df$index <- rownames(df)
## Using ggmap's geocoding service, which I can enable with my Google API
# Hiding my key since this repo is public.  Writing to my renv.
#register_google(key = , write = TRUE)
# Now get all the nodes as a set, make a new df, and add lon and lat columns
origins <- (select(df, ORIGIN, index))
colnames(origins) <- c('iata_code','index')
dests <- (select(df, DEST, index))
colnames(dests) <- c('iata_code','index')
nodes = unique(c(origins$iata_code, dests$iata_code))
node_df <- as.data.frame(nodes)
node_df$nodes <- as.character(node_df$nodes)
node_df$lon <- NA
node_df$lat <- NA
# This block of code will actually pass the nodes to Google's API for reverse geolocation
# Dont run it too often, only so many API calls
#for(i in 1:nrow(node_df))
#{
#  print(node_df$nodes[i])
# need to add '+Airport' to resolve ambiguities
#  result <- geocode(paste((node_df$nodes[i]),'+Airport'))
#  node_df$lon[i] <- as.numeric(result$lon)
#  node_df$lat[i] <- as.numeric(result$lat)
#}
#node_df$iata_code <- node_df$nodes
#node_df <- select(node_df, c(iata_code, lat, lon))
#write_csv(node_df, 'data/node_locations.csv')
node_df <- read_csv('data/node_locations.csv')
## Merge locs to the edges
origins_loc <- merge(origins, node_df, by = 'iata_code', full.x = T)
colnames(origins_loc) <- c('origin_iata', 'index', 'origin_lat', 'origin_lon')
dests_loc <- merge(dests, node_df, by = 'iata_code', full.x = T)
colnames(dests_loc) <- c('dest_iata', 'index', 'dest_lat', 'dest_lon')
edge_locs <- merge(origins_loc, dests_loc, by = 'index')
edge_locs_no_na <- na.omit(edge_locs)
edge_locs_clean <- edge_locs_no_na %>%
group_by(origin_iata, origin_lon, origin_lat,
dest_iata, dest_lon, dest_lat) %>%
summarise(total = n())
origin_counts <- edge_locs_no_na %>%
group_by(origin_iata) %>%
summarise(total = n())
# Plot on a map.  Once I get the geo coords in, we can start messing around with visuals.
# I'd like to do a time lapse to show the flights over days/months with different colors
# for different attributes, such as airline or how early/late each flight is.
df_map <- edge_locs_clean[order(-edge_locs_clean$total),][1:10,]
